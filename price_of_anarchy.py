import csv
import pickle
from fractions import Fraction
import pdb
from pprint import pprint

def fix_spacing(filename: str) -> None:
    fin = open(filename, "r")
    fout = open(f"{filename[:-4]}_fixed.txt", "w")

    for line in fin:
        fout.write(' '.join(line.split()))
        fout.write("\n")
        
    fin.close()
    fout.close()

# puts the output generated by lrsnash into a more readable/understandable format
def read_nash_file(filename: str, key_filename: str, pure_only: bool = True) -> None:
    key = pickle.load(open(key_filename, "rb"))
    strategies = [] # format as: {sender matrix, receiver matrix, payoff}
    pure_strategies = []
    num_nash_equilibria = 0
    num_pure_nash_equilibria = 0
    with open(filename, "r") as trial_file:
        reader = csv.reader(trial_file, delimiter=" ")
        receiver_matrices = []
        for line in reader:
            if len(line) == 0 or line[0] == "*lrsnash:lrslib":
                continue
            if line[0] == "2":
                strategy_vec = [float(Fraction(s)) for s in line[1:-1]]
                if pure_only:
                    if any([True if i != 0 and i != 1 else False for i in strategy_vec]):
                        continue
                    rec_matrix = key["receiver"][strategy_vec.index(1)]
                    receiver_matrices.append(rec_matrix)
                else:
                    raise NotImplementedError
            elif line[0] == "1":
                strategy_vec = [float(Fraction(s)) for s in line[1:-1]]
                payoff = float(Fraction(line[-1]))
                if pure_only:
                    if any([True if i != 0 and i != 1 else False for i in strategy_vec]):
                        receiver_matrices = []
                        continue
                    sender_matrix = key["sender"][strategy_vec.index(1)]
                    for receiver_matrix in receiver_matrices:
                        pure_strategies.append({
                            "sender_matrix": sender_matrix,
                            "receiver_matrix": receiver_matrix,
                            "payoff": payoff
                        })
            else:
                continue

    if pure_only:
        return pure_strategies

def price_of_anarchy(pure_strategies: List, n: int, m: int) -> float:
    max_payoff = min([n, m])
    worst_payoff = float("inf")
    worst_sender = None
    worst_receiver = None
    
    for strategy in pure_strategies:
        if strategy["payoff"] < worst_payoff:
            worst_sender = strategy["sender_matrix"]
            worst_receiver = strategy["receiver_matrix"] 
            worst_payoff = strategy["payoff"]

    return worst_payoff

def price_of_stability(pure_strategies: List, n: int, m: int) -> float:
    max_payoff = min([n, m])
    best_payoff = -float("inf")
    best_sender = None
    best_receiver = None

    for strategy in pure_strategies:
        if strategy["payoff"] > best_payoff:
            best_sender = strategy["sender_matrix"]
            best_receiver = strategy["receiver_matrix"] 
            best_payoff = strategy["payoff"]

    return best_payoff



if __name__ == "__main__":
    fix_spacing("trial_2_results.txt")
    pure_strats = read_nash_file("trial_2_results_fixed.txt", "nash_trials/testing_key.p", "out.txt")
    price_of_anarchy(pure_strats)
        